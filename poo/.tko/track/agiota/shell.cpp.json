{
    "patches": [
        {
            "label": "2025-02-25_00-27-32",
            "content": "#include <sstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <memory>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ntemplate <typename CONTAINER, typename FN>\nstring map_join(const CONTAINER& container, FN fn, string sep = \", \") {\n    stringstream ss;\n    for (auto it = container.begin(); it != container.end(); ++it) {\n        ss << (it != container.begin() ? sep : \"\") << fn(*it);\n    }\n    return ss.str();\n}\n\nenum class Label {\n    GIVE, TAKE, PLUS\n};\n\nstring labelToString(Label label) {\n    switch (label) {\n        case Label::GIVE: return \"give\";\n        case Label::TAKE: return \"take\";\n        case Label::PLUS: return \"plus\";\n        default: return \"unknown\";\n    }\n}\n\nclass Operation {\n    int id;\n    string name;\n    Label label;\n    int value;\n\npublic:\n    Operation(int id, string name, Label label, int value) : id(id), name(name), label(label), value(value) {}\n\n    int getId() const { return id; }\n    string getName() const { return name; }\n    int getValue() const { return value; }\n    Label getLabel() const { return label; }\n\n    string str() const {\n        stringstream ss;\n        ss << \"id:\" << id << \" \" << labelToString(label) << \":\" << name << \" \" << value;\n        return ss.str();\n    }\n};\n\nclass Client {\n    string name;\n    int limite;\n    list<shared_ptr<Operation>> operations;\n\npublic:\n    Client(string name, int limite) : name(name), limite(limite) {}\n\n    string getName() const { return name; }\n    int getLimite() const { return limite; }\n\n    void addOperation(shared_ptr<Operation> op) {\n        operations.push_back(op);\n    }\n\n    int getBalance() const {\n        int balance = 0;\n        for (const auto& op : operations) {\n            if (op->getLabel() == Label::GIVE || op->getLabel() == Label::PLUS)\n                balance += op->getValue();\n            else if (op->getLabel() == Label::TAKE)\n                balance -= op->getValue();\n        }\n        return balance;\n    }\n\n    bool isAlive() const { return getBalance() >= -limite; }\n\n    string str() const {\n        stringstream ss;\n        ss << name << \" \" << getBalance() << \"/\" << limite;\n        return ss.str();\n    }\n\n    list<shared_ptr<Operation>> getOperations() const {\n        return operations;\n    }\n};\n\nclass Agiota {\n    map<string, shared_ptr<Client>> alive;\n    map<string, shared_ptr<Client>> dead;\n    list<shared_ptr<Operation>> operations;\n    list<shared_ptr<Operation>> deadOperations;\n    int nextOpId = 0;\n\npublic:\n    void addClient(string name, int limite) {\n        if (alive.count(name) || dead.count(name)) {\n            cout << \"fail: cliente ja existe\\n\";\n            return;\n        }\n        alive[name] = make_shared<Client>(name, limite);\n    }\n\n    void show() const {\n        stringstream ss;\n\n        // Ordena e exibe clientes vivos\n        vector<shared_ptr<Client>> clientesOrdenados;\n        for (const auto& [_, client] : alive)\n            clientesOrdenados.push_back(client);\n        sort(clientesOrdenados.begin(), clientesOrdenados.end(),\n             [](const shared_ptr<Client>& a, const shared_ptr<Client>& b) {\n                 return a->getName() < b->getName();\n             });\n        for (const auto& cliente : clientesOrdenados)\n            ss << \":) \" << cliente->str() << endl;\n\n        // Exibe opera\u00e7\u00f5es na ordem global\n        for (const auto& op : operations)\n            ss << \"+ \" << op->str() << endl;\n\n        // Ordena e exibe clientes mortos\n        vector<shared_ptr<Client>> clientesOrdenadosMortos;\n        for (const auto& [_, client] : dead)\n            clientesOrdenadosMortos.push_back(client);\n        sort(clientesOrdenadosMortos.begin(), clientesOrdenadosMortos.end(),\n             [](const shared_ptr<Client>& a, const shared_ptr<Client>& b) {\n                 return a->getName() < b->getName();\n             });\n        for (const auto& cliente : clientesOrdenadosMortos)\n            ss << \":( \" << cliente->str() << endl;\n\n        // Exibe opera\u00e7\u00f5es dos clientes mortos\n        for (const auto& op : deadOperations)\n            ss << \"- \" << op->str() << endl;\n\n        cout << ss.str();\n    }\n\n    void showClient(string name) const {\n        if (alive.count(name)) {\n            auto client = alive.at(name);\n            cout << client->str() << endl;\n            for (const auto& op : client->getOperations())\n                cout << op->str() << endl;\n        } else if (dead.count(name)) {\n            auto client = dead.at(name);\n            cout << \"@\" << client->str() << endl;\n            for (const auto& op : client->getOperations())\n                cout << op->str() << endl;\n        } else {\n            cout << \"fail: cliente nao existe\\n\";\n        }\n    }\n\n    void give(string name, int value) {\n        if (!alive.count(name)) {\n            cout << \"fail: cliente nao existe\\n\";\n            return;\n        }\n\n        auto client = alive[name];\n        if (client->getBalance() + value > client->getLimite()) {\n            cout << \"fail: limite excedido\\n\";\n            return;\n        }\n\n        auto op = make_shared<Operation>(nextOpId++, name, Label::GIVE, value);\n        client->addOperation(op);\n        operations.push_back(op);\n    }\n\n    void take(string name, int value) {\n        if (!alive.count(name)) {\n            cout << \"fail: cliente nao existe\\n\";\n            return;\n        }\n\n        auto op = make_shared<Operation>(nextOpId++, name, Label::TAKE, value);\n        operations.push_back(op);\n        alive[name]->addOperation(op);\n\n        if (!alive[name]->isAlive()) {\n            dead[name] = alive[name];\n            alive.erase(name);\n\n            operations.remove_if([&](const shared_ptr<Operation>& op) {\n                if (op->getName() == name) {\n                    deadOperations.push_back(op);\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n\n    void kill(string name) {\n        if (!alive.count(name)) {\n            cout << \"fail: cliente nao existe\\n\";\n            return;\n        }\n\n        auto client = alive[name];\n        dead[name] = client;\n        alive.erase(name);\n\n        operations.remove_if([&](const shared_ptr<Operation>& op) {\n            if (op->getName() == name) {\n                deadOperations.push_back(op);\n                return true;\n            }\n            return false;\n        });\n    }\n\n    void plus() {\n        list<string> clientes;\n        for (const auto& [name, _] : alive)\n            clientes.push_back(name);\n\n        for (const auto& name : clientes) {\n            auto client = alive[name];\n            int juros = ceil(client->getBalance() * 0.1);\n            auto op = make_shared<Operation>(nextOpId++, name, Label::PLUS, juros);\n            client->addOperation(op);\n            operations.push_back(op);\n\n            if (!client->isAlive()) {\n                dead[name] = client;\n                alive.erase(name);\n\n                operations.remove_if([&](const shared_ptr<Operation>& op) {\n                    if (op->getName() == name) {\n                        deadOperations.push_back(op);\n                        return true;\n                    }\n                    return false;\n                });\n            }\n        }\n    }\n};\n\n\nint main() {\n    Agiota agiota;\n    while (true) {\n        string line, cmd;\n        getline(cin, line);\n        cout << \"$\" << line << endl;\n\n        stringstream ss(line);\n        ss >> cmd;\n\n        if (cmd == \"end\") {\n            break;\n        } else if (cmd == \"addCli\") {\n            string name;\n            int limite;\n            ss >> name >> limite;\n            agiota.addClient(name, limite);\n        } else if (cmd == \"show\") {\n            agiota.show();\n        } else if (cmd == \"showCli\") {\n            string name;\n            ss >> name;\n            agiota.showClient(name);\n        } else if (cmd == \"kill\") {\n            string name;\n            ss >> name;\n            agiota.kill(name);\n        } else if (cmd == \"give\") {\n            string name;\n            int value;\n            ss >> name >> value;\n            agiota.give(name, value);\n        } else if (cmd == \"take\") {\n            string name;\n            int value;\n            ss >> name >> value;\n            agiota.take(name, value);\n        } else if (cmd == \"plus\") {\n            agiota.plus();\n        } else {\n            cout << \"fail: comando invalido\\n\";\n        }\n    }\n}"
        }
    ]
}